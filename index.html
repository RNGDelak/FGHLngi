<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fast Growing Hierarchy Lngi</title>

<style>
    body {
        background-color: black;
        color: #00ffff;
        font-family: 'Noto Sans', sans-serif;
    }

    #output {
        font-size: 1.5rem;
        white-space: normal;
        word-wrap: break-word;
        position: relative;
        font-style: italic;
    }

    .glow {
        text-shadow:
            0 0 4px #00ffff,
            0 0 10px #00ffff,
            0 0 20px #00aaff,
            0 0 40px #00aaff,
            0 0 80px #00aaff;
    }

    input, button {
        background: black;
        color: #00ffff;
        border: 1px solid #00ffff;
        padding: 4px 8px;
        font-size: 1rem;
    }

    button {
        cursor: pointer;
    }
</style>

<script>
    // Final boss-level numberToCanonicalFGH -> HTML-only output (Option A)
      function numberToCanonicalFGH(nInput, baseInput, options = {}) {
        const n = BigInt(nInput);
        const base = BigInt(baseInput);
        if (n < base) throw new Error("n must be >= base");

        const MAX_K = options.maxK ?? 4;               // limit search depth for k
        const MAX_EXPR_STRING = options.maxExprString ?? 1e308; // truncate safety
        const MAX_F0_EXPAND = options.maxF0Expand ?? 1e308 // cap explicit f0 expansions

        // Memoization for f_k(x) results: key = `${k},${x}`
        const fkMemo = new Map();

        // compute f_k(x) but stop early if > limit.
        function compute_fk_lte_limit(k, x, limit) {
          k = Number(k);
          x = BigInt(x);
          limit = BigInt(limit);
          const key = `${k},${x}`;
          if (fkMemo.has(key)) return fkMemo.get(key);

          function store(res) { fkMemo.set(key, res); return res; }

          // f0: x + 1
          if (k === 0) {
            const v = x + 1n;
            return store(v > limit ? { exceeded: true } : { value: v, exceeded: false });
          }

          // f1: 2x
          if (k === 1) {
            const v = x << 1n;
            return store(v > limit ? { exceeded: true } : { value: v, exceeded: false });
          }

          // f2: x * 2^x
          if (k === 2) {
            if (x > 4096n) return store({ exceeded: true });
            const v = x * (1n << x);
            return store(v > limit ? { exceeded: true } : { value: v, exceeded: false });
          }

          // k >= 3: hyper-exponential; guard if x too big
          if (x > 32n) return store({ exceeded: true });

          // iterate applying f_{k-1} x times
          let v = x;
          for (let i = 0; i < Number(x); i++) {
            const lower = compute_fk_lte_limit(k - 1, v, limit);
            if (lower.exceeded) return store({ exceeded: true });
            v = lower.value;
            if (v > limit) return store({ exceeded: true });
          }
          return store({ value: v, exceeded: false });
        }

        // ---------- Expression representation ----------
        function baseNode(v) { return { type: "base", v: BigInt(v), hash: `B${v.toString()}` }; }
        function fNode(k, inner) { return { type: "f", k: Number(k), inner, hash: `F${k},${inner.hash}` }; }

        // Evaluate symbolic expression to a numeric value <= limit
        const evalMemo = new Map();
        function evalExprLimited(expr, limit) {
          const limitBig = BigInt(limit);
          const memoKey = expr.hash + '|' + limitBig.toString();
          if (evalMemo.has(memoKey)) return evalMemo.get(memoKey);

          // flatten frames
          const frames = [];
          let cur = expr;
          while (cur.type !== "base") {
            if (cur.type === "f") {
              frames.push({ k: cur.k });
              cur = cur.inner;
            } else {
              throw new Error("Unknown expr node type: " + JSON.stringify(cur));
            }
          }

          let value = cur.v;
          for (let i = frames.length - 1; i >= 0; i--) {
            const r = compute_fk_lte_limit(frames[i].k, value, limitBig);
            if (r.exceeded) {
              const res = { exceeded: true };
              evalMemo.set(memoKey, res);
              return res;
            }
            value = r.value;
          }
          const res = { value: value, exceeded: false };
          evalMemo.set(memoKey, res);
          return res;
        }

        // ---------- Core canonical builder (greedy) ----------
        let expr = baseNode(base);
        if (base === n) return base.toString();

        while (true) {
          const ev = evalExprLimited(expr, n);
          if (!ev.exceeded && ev.value === n) break;
          if (ev.exceeded) throw new Error("evaluation exceeded unexpectedly for current expression");

          const currentVal = ev.value; // numeric value < n

          // find largest k (0..MAX_K) such that f_k(currentVal) <= n
          let chosenK = -1;
          for (let k = 0; k <= MAX_K; k++) {
            const r = compute_fk_lte_limit(k, currentVal, n);
            if (!r.exceeded) chosenK = k;
            else break;
          }
          if (chosenK === -1) throw new Error("Cannot find any f_k that keeps value <= n (unexpected).");

          if (chosenK === 0) {
            const diff = n - currentVal;
            if (diff < 0n) throw new Error("negative difference (bug)");
            if (diff > BigInt(MAX_F0_EXPAND)) {
              throw new Error(
                `Difference ${diff.toString()} is too large to expand as explicit F<sub>0</sub>(...) wrappers without compression. ` +
                `Increase maxF0Expand if you understand the implications.`
              );
            }
            const times = Number(diff);
            for (let i = 0; i < times; i++) expr = fNode(0, expr);

            const finalEval = evalExprLimited(expr, n);
            if (!finalEval.exceeded && finalEval.value === n) break;
            throw new Error("failed to reach n after applying explicit F<sub>0</sub> wrappers");
          }

          // wrap once with chosenK >= 1
          expr = fNode(chosenK, expr);

          // guard: if string would be enormous, abort with truncated text
          const sTest = exprToStringWithoutConversion(expr);
          if (sTest.length > MAX_EXPR_STRING) {
            return sTest.slice(0, MAX_EXPR_STRING) + "...(truncated)";
          }
        }

        // Now we have expr that evaluates to n. Build raw HTML-ish string (numbers not rewritten yet).
        const raw = exprToStringWithoutConversion(expr);

        // Post-process: rewrite numeric literals > base (except base itself) into canonical FGH recursively.
        return rewriteNumbersOutsideTags(raw, base);

        // -------------------------
        // String builders & helpers
        // -------------------------

        // formatF: produces HTML string for F_k (with optional superscript run)
        function formatF(k, run, inner) {
          if (run > 1) {
            return `f<sub>${k}</sub><sup>${run}</sup>(${inner})`;
          }
          return `f<sub>${k}</sub>(${inner})`;
        }

        // Build string from expr WITHOUT converting numbers to FGH — numbers remain as digits.
        function exprToStringWithoutConversion(expr) {
          const frames = [];
          let cur = expr;
          while (cur.type !== "base") {
            frames.push(cur.k);
            cur = cur.inner;
          }

          let s = cur.v.toString();

          for (let i = frames.length - 1; i >= 0; ) {
            const k = frames[i];
            let run = 1;
            let j = i - 1;
            while (j >= 0 && frames[j] === k) { run++; j--; }

            // If run > base collapse into F_k^run(...), else produce repeated F_k(...) explicitly
            if (run > Number(base)) {
              s = formatF(k, run, s);
            } else {
              for (let t = 0; t < run; t++) s = formatF(k, 1, s);
            }
            i = j;

            if (s.length > MAX_EXPR_STRING) return s.slice(0, MAX_EXPR_STRING) + "...(truncated)";
          }
          return s;
        }

        // Rewrite numbers only outside of HTML tags.
        // We split the string by tags and only replace numbers in non-tag parts.
        function rewriteNumbersOutsideTags(str, baseVal) {
          const b = BigInt(baseVal);

          // Split keeping tags: any "<...>" is a separate token.
          // This preserves tags like <sub>2</sub> so we don't rewrite the 2 inside them.
          const parts = str.split(/(<[^>]+>)/g);

          for (let p = 0; p < parts.length; p++) {
            const piece = parts[p];
            if (!piece || piece[0] === "<") {
              // it's a tag — do not modify
              continue;
            }

            // replace numbers in this plain-text piece
            parts[p] = piece.replace(/\b\d+\b/g, (m) => {
              const x = BigInt(m);
              if (x === b) return m;   // keep base literal unchanged
              if (x < b * 1n) return m;     // keep smaller numbers unchanged
              // For numbers > base: recursively obtain canonical HTML string.
              // This is safe because the recursive call will produce HTML with tags;
              // it will be inserted into the current output as a chunk.
              return numberToCanonicalFGH(x, b, options);
            });
          }

          return parts.join("");
        }
      }



    
document.addEventListener("DOMContentLoaded", () => {

    // ----- increment slider -----
    const slider = document.getElementById("incrementSlider");
    const valueLabel = document.getElementById("incrementValue");

    function sliderToValue(v) {
        return Math.pow(10, v);
    }

    function updateIncrement() {
        window.increment = sliderToValue(parseFloat(slider.value));
        valueLabel.textContent = window.increment.toPrecision(3);
    }

    slider.addEventListener("input", updateIncrement);
    updateIncrement();

    // ----- base selector -----
    let base = 2n;
    const baseInput = document.getElementById("baseInput");
    const basePlus = document.getElementById("basePlus");
    const baseMinus = document.getElementById("baseMinus");

    function updateBase(v) {
        v = Math.max(2, v | 0);
        baseInput.value = v;
        base = BigInt(v);
        updateOutput();
    }

    baseInput.addEventListener("input", () =>
        updateBase(parseInt(baseInput.value, 10) || 2)
    );

    basePlus.addEventListener("click", () =>
        updateBase(parseInt(baseInput.value, 10) + 1)
    );

    baseMinus.addEventListener("click", () =>
        updateBase(parseInt(baseInput.value, 10) - 1)
    );

    // ----- main loop -----
    let i = 2;
    let lastInt = 1;

    const output = document.getElementById("output");

    function updateOutput() {
        output.innerHTML =
            numberToCanonicalFGH(BigInt(Math.floor(i)), base);
    }

    setInterval(() => {
        document.getElementById("i").textContent =
            "i = " + Math.round(i * 1000) / 1000;

        const cur = Math.floor(i);
        if (cur !== lastInt) {
            lastInt = cur;
            updateOutput();
        }
        i += window.increment;
    }, 0);
});
</script>
</head>

<body>
<h1>Fast Growing Hierarchy Lngi</h1>

<label>
    Increment:
    <span id="incrementValue">1</span>
</label><br>

<input
    type="range"
    id="incrementSlider"
    style="width: 50%;"
    min="-4"
    max="1.176091"
    step="0.01"
    value="-4"
>

<!-- Base selector (between slider and iteration count) -->
<div style="margin: 12px 0;">
    <label>Base :</label>
           <input id="baseInput" type="number" min="2" value="2" style="width:70px;text-align:center;">
    <button id="baseMinus">−</button>
    
    <button id="basePlus">+</button>
</div>

<h3 id="i" class="glow">i = 0</h3>

  <p id="output" class = "glow" style="font-style: italic; font-family: 'Noto Sans';font-size: 1.5rem;">
      f0(0)
  f<sub>0</sub>(0)</p>

</body>
</html>
